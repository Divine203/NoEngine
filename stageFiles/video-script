INTRO

This is a Graphics Engine. Made from scratch with NO shaders, NO Open GL and NO GLSL.

Computer Graphics is one of those topics that are just challenging to understand even of experienced programmers. 

And in this video i hope to simplify the subject so you're not as lost as I was when i started.

I'm going to walk you through all the steps. Starting with basic vertex rendering, rotations, Camera movements, all the way to texture mapping and even simple lighting calculations.

Were going to be using only Math equations and some JavaScript Wizadry to simulate real 3D graphics.



BODY 

So to start i referenced my canvas element and made a game loop to render a blank screen.

Now the first thing to note about 3D graphics is that this isn't actually 3D. it's a projection of 3D coordinates onto a 2D space.

Everything you see in an engine, even the most minute details are all made of tiny dots all connected as triangles. 

These are called vertices or vertex if it's singular. 

These vertices are moved around the screen space using something called Matrix multiplication, to create the illusion of a 3D enviroment.

Essentially you treat the vertex coordinates (x, y, z) like a 1 dimensional matrix and multiply it by another matrix to move the vertex in screen space. 

There's usually an extra column, the homogenous coordinates, But this is only needed if you want to actually move objects via Matrix multiplication or do more than one transformation at once. 

So the extra coordinate helps you hold translations.

But I'm only doing simple transformations for my engine and since we can move objects by simply offsetting their positions, we'll stick to just 3. Also to keep the math simple.



// coding part

So we'll start with creating a vertex class that takes an x, y and z position, with a function to draw the vertex. 

We can then create our first vertex and call the draw function in the main loop,

*shows results*

Lets add 3 more to make a square.

Now remember to move this vertices we need to multiply them by Matrices. The question is, what are these matrices??

Luckily we don't have to come up with this stuff ourselves. People much smarter than me already came up with solutions

Sources like wikipedia have all the info, so we'll just shamelessly steal from there.

The first is the projection matrix. Its values are constant, so we can just store it in a variable.

The rest are rotations, but since their values are based of an angle, we'll have to wrap them in a function.

We'll also write a function to multiply a vertex by a matrix.

Essentially you take each row of the matrix, multiply the values by the 3 coordinates and then sum it all together to get its new position.

We'll create a variable to store our starting angle. 

The value is in radians so we'll increment by a small amount let's say. 0.02

Then we can just multiply one of our rotation matrix by each vertex. To make the square rotate.

*shows results*

Now It works, we just dont see anything cause our origin is at the edge of the canvas by default, making the object rotate off the screen. 

The solution is quite tricky but essentially we need to centralize the origin. 

We do this by moving the object's center to the default origin. 

We do our rotation in that position. And then move it back, just before we project to the screen.

As you can see our object is rotating as it should. 

*shows results*

We can even add a couple more rotations.

*shows results*

Lets add a few more vertices to make this into a cube.

*shows results*

Now Our vertices are moving correctly, we just need to connect them as triangles to form our shape. 

We first need a function that takes 2 positions x and y and draws a line connecting the 2.

We can then set up a matrix of triangles, where each row represents one triangle, with its values being 3 vertices that make up the 3 points of the triangle. (*show diagram of cube with numbered vertices*)

then in our game loop instead of just drawing the vertex. We push the projected vertices into an array we can access outside the scope. 

We loop through our triangle matrix and then use the 3 indexes to get the 3 vertices in the array that make up the triangle. Then we just simply draw 3 lines to connect the 3 points. 

And as you can see we have our cube made up of triangles, pretty sick.

*shows results*

The system we just created is what i call the foundation of 3D graphics. As long as we have the correct vertex positions of an object and we know how all triangles are connected, You can render pretty much 

anything.

So if your thinking, we could totally render more complex shapes. You're absolutely correct.

If we wanted to render a sphere for example.

We start by setting up a radius and segments which is how many cuts around the sphere were making.

We loop through the segment and calculate the latitude and longitude of the sphere, basically from top to bottom and around the sphere respectively, We can call these theta and phi.

Then we find their x, y and z coordinates using simple trigonometry formulas. 

Then just like before, we connect them into triangles by linking points to their neighbors, forming tiny surface patches.

This is all theory by the way.

*shows a wikipedia screenshot*

And we have rotating sphere. We can change the amount of segments to adjust its smoothness, and even its radius to adjust it's size.

*shows results*


Now that our simulation is working perfectly...let's delete everything *sitcom crowd shock sound effect*

Well...not everything, as cool as this looks, we're not using a Graphics library, so naturally we dont have access to any form of GPU or Hardware acceleration. Meaning our engine is running purely on the CPU.

If we're going to be adding textures and lighting in the future, we'll sadly have to compromise on the amount of vertices and triangles being rendered, so my PC doesnt catch fire.

For this reason we'll be sticking with only cubes for our engine. And since we're rendering only cubes, we can scrap triangles entirely and render everything as faces instead. 

*shows results*

[skit]

me1: But you know whats better than a cube
me2: More cubes?
me1: Yes...wait how'd you guess that
me2: Dude we're literally the same perso...

We can just wrap our code into a cube class, that takes x, y, z, width, height and depth.

Then we use these values to set up each vertex accordingly. 

we'll start with 3 cubes and pass them in a world array.

Now we have multiple cubes rendered.

*shows results*


Next up CAMERAS

Cameras are basically just rotations with perspective. Rather than just moving the objects, We move our camera object and make everything else transform in respect to it.

So we start with a camera class and pass in our key variables. In case your wondering, the extra z is basically how far the projected screen is from our eyes.

I already have a keyboard control file prepared, so we just need to check which keys are pressed and adjust the variables accordingly.

we create our camera instance.

Translate all objects vertices in respect to the camera position, add our rotations, project the results and then offset the projected coordinates by the camera's position.


*shows results*

And as you can see, we have our moving camera. (*future 'sensational' meme*)

The most challenging part of this project for me was texturing. 

See the standard way of rendering textures, is reading the pixels in the image file as UV coordinates. the top left being (0,0), the bottom right being (1,1) and so on.

These values are then used to draw the pixels on each triangle. And as you probably guessed, this is way too performance intensive for our engine, cause again everything is being run on the CPU.

So i came up with my own solution. I call it the Scan-line technique. 

Essentially you draw vertical slices on each face of the cube starting from the left line all the way to the right, the slices are drawn as cuts from our texture image. This technique is borrowed from 

old pseudo 3D engines which used a similar technique to render their walls. 


*shows results*

Its quite smooth, but It's still CPU intensive.

The frustrating part is all we need is to render images with skewed edges, that's it. If we could do just that, it would be as easy as just slapping a picture on all faces. 

I some how stumbled upon a library that did this exactly, I gave it a try with hopes that they had a more optimized way of rendering it..... It was even worse lol. *vin boom sound effect*

Turns out their just using a similar technique as mine but with alot more fancy calculations. No hate tho, im probably just not their target audience. 

So sadly this would have to do for now.

*shows results*


Which brings me to the part i enjoyed writing the most. "LIGHTING".

Lighting only needs 2 things a light source and a way to dim and brighten each face. 

We can adjust the brightness of each face by drawing a black filled quadilateral on all sides and adjust their opacity.

As for the light source... its just another cube rendered with a solid color and a blur filter. 

*shows results*

Now the setup is complete we just need a way to tell how bright each face should be based on it's distance from the lightsource. 

Since the distance is in world space, we don't need to worry about projection. We just need to find the center of each face, calculate its distance from the light source and store it as an array in the object.

We can then use the brightness values to adjust the opacity of the black quadilaterals.

We add a little rotation movement to the lightsource, and just like that we have lighting.

*shows results*

For funzies i added the sphere back but with just a solid color, I then added the same brightness calculation on all it's triangles.

*shows results*




OUTRO


I honetly find it fascinating how you can just casually make stunning scenes like this with just math and some code, it's almost like black magic to be honest.

Which by the way took me a whole month to make mostly cause I just SUCK at math, but... I'm glad it turned out well in the end. 

I plan to make more cool stuff like this in the future maybe with an actual Graphics library so we can go crazy with rendering and not worry about performance too much. 

I'll link all the materials i used to study as well as the source code if you want to dive deeper on your own.

I hope this video was helpful, as always thanks for watching and I'll see you in the next one. God Bless.
