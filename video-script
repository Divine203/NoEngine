INTRO

This is a Graphics Engine. Made from scratch with NO shaders, NO Open GL and NO GLSL.

Computer Graphics is one of those topics that are just challenging to understand even of experienced programmers. 

And in this video i hope to simplify the subject so you're not as lost as I was when i started.

I'm going to walk you through all the steps. Starting with basic vertex rendering, rotations, Camera movements, all the way to texture mapping and even simple lighting calculations.

Were going to be using only Math equations and some JavaScript Wizadry to simulate real 3D graphics.



BODY 

So to start i referenced my canvas element and made a game loop to render a blank screen.

Now the first thing to note about 3D graphics is that this isn't actually 3D. it's a projection of 3D coordinates onto a 2D space.

Everything you see in an engine, even the most minute details are all made of tiny dots all connected as triangles. 

These are called vertices or vertex if it's singular. 

These vertices are moved around the screen space using something called Matrix multiplication, to create the illusion of a 3D enviroment.

Essentially you treat the vertex coordinates (x, y, z) like a 1 dimensional matrix and multiply it by another matrix to move the vertex in screen space. 

There's usually an extra column, the homogenous coordinates, But this is only needed if you want to actually move objects via Matrix multiplication or do more than one transformation at once. 

So the extra coordinate helps you hold translations.

But I'm only doing simple transformations for my engine and since we can move objects by simply offsetting their positions, we'll stick to just 3. Also to keep the math simple.



// coding part

So we'll start with creating a vertex class that takes an x, y and z position, with a function to draw the vertex. 

We can then create our first vertex and call the draw function in the main loop,

*shows results*

Lets add 3 more to make a square.

Now remember to move this vertices we need to multiply them by Matrices. The question is, what are these matrices??

Luckily we don't have to come up with this stuff ourselves. People much smarter than me already came up with solutions

Sources like wikipedia have all the info, so we'll just shamelessly steal from there.

The first is the projection matrix. Its values are constant, so we can just store it in a variable.

The rest are rotations, but since their values are based of an angle, we'll have to wrap them in a function.

We'll also write a function to multiply a vertex by a matrix.

Essentially you take each row of the matrix, multiply the values by the 3 coordinates and then sum it all together to get its new position.

We'll create a variable to store our starting angle. 

The value is in radians so we'll increment by a small amount let's say. 0.02

Then we can just multiply one of our rotation matrix by each vertex. To make the square rotate.

*shows results*

Now It works, we just dont see anything cause our origin is at the edge of the canvas by default, making the object rotate off the screen. 

The solution is quite tricky but essentially we need to centralize the origin. 

We do this by moving the object's center to the default origin. 

We do our rotation in that position. And then move it back, just before we project to the screen.

As you can see our object is rotating as it should. 

*shows results*

We can even add a couple more rotations.

*shows results*

Lets add a few more vertices to make this into a cube.

*shows results*

Our vertices now are moving correctly, so we just need to connect them as triangles to form our shape. 

We first need a function that takes 2 positions x and y and draws a line connecting the 2.

We can then set up a matrix of triangles, where each row represents one triangle, with its values being 3 vertices that make up the 3 points of the triangle. (*show diagram of cube with numbered vertices*)

then in our game loop instead of just drawing the vertex. We push the projected vertices into a seperate array we can access outside the scope. 

We loop through our triangle matrix and then use the 3 indexes to get the 3 vertices in the projected array that make up the triangle. The we just simply draw 3 lines to connect the 3 points. 

And as you can see we have our cube made up of triangles, pretty sick.

*shows results*

The system we just created is essentially the foundation of 3D graphics. As long as we have the correct vertex positions and we know how all triangles are connected, You can render pretty much anything.

So if your thinking, we could totally render more complex shapes. You're absolutely correct.

If we wanted to render a sphere for example.

We start by setting up a radius and segments which is how many cuts around the sphere were making.

We loop through the segment and calculate the latitude and longitude of the sphere, basically from top to bottom and around the sphere respectively, We can call these theta and phi.

Then we find their x, y and z coordinates using simple trigonometry formulas. 

Then just like before, we connect them into triangles by linking points to their neighbors, forming tiny surface patches.

This is all theory by the way.

*shows a wikipedia screenshot*

And we have rotating sphere. We can change the amount of segments to adjust its smoothness, and even its radius to adjust it's size.

*shows results*


Now that our simulation is working perfectly...let's delete everything *sitcom crowd shock sound effect*

Well...not everything, as cool as this looks, we're not using a Graphics library, so naturally we dont have access to any form of GPU or Hardware acceleration. Meaning our engine is running purely on the CPU.

If we're going to be adding textures and lighting in the future, we'll have to compromise on the amount of vertices and triangles being rendered, so my PC doesnt catch fire.

For this reason we'll be sticking with only cubes for our engine. And since we're rendering only cubes, we can scrap triangles entirely and render everything as faces instead. 

*shows results*

[skit]

me1: But you know whats better than a cube
me2: More cubes?
me1: Yeah...wait how'd you guess that
me2: Dude we're literally the same perso...

We can just wrap our code into a cube class, that takes x, y, z, width, height and depth.

Then we use this values to set up each vertex accordingly. 

we'll start with 3 cubes and pass them in a world array.

Now we have multiple cubes rendered.

*shows results*


Next up CAMERAS

Cameras are just basically rotations with perspective. Rather than just moving the objects, You move our camera object and make everything else transform in respect to it.

So we start with a camera class and pass in our key variables. Imcase your wondering the extra z is not a position but a perspective distortion, in simple terms, how far the projected screen is from our eyes.

I already have a keyboard control file prepared, so we just need to check which keys are pressed and adjust the variables accordingly.

we create our camera instance.

Translate all objects vertices in respect to the camera position, add our rotations, project the results and then offset the projected coordinates by the camera's position.


*shows results*

And as you can see, we have our moving camera. (*future 'sensational' meme*)






OUTRO